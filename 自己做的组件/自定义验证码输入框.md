# 自定义验证码输入框

![图片示例](https://github.com/gneL1/Flutter-/blob/master/%E8%87%AA%E5%B7%B1%E5%81%9A%E7%9A%84%E7%BB%84%E4%BB%B6/photos/UtilVerification/verification_01.gif)

&emsp;&emsp;分析一下需求。
1. 点击输入框弹出软键盘，关闭软键盘时取消输入框的焦点。
2. 当输入达到最大长度时，自动关闭软键盘。
3. 输入完成时获取输入的内容。

* 焦点问题  
&emsp;&emsp;通过三层组件来实现验证码输入框的效果。首先是一个TextField放置在最下面，这个输入框只是用来获取用户输入的值，实际操作中用户时看不到的。
第二层是一行Container包裹Text,用来模拟用户看到的输入内容以及装饰输入框。第三次是一个Listener，用来监听用户的点击事件。  
&emsp;&emsp;用户点击输入框时，通过```FocusScope.of(context).requestFocus(_focusNode);```来弹出软键盘。  
&emsp;&emsp;关掉输入框时，通过```FocusScope.of(context).requestFocus(FocusNode());```来取消焦点。

* 自动关闭软键盘  
&emsp;&emsp;在TextField的回调```onChanged(String text)```里监听输入内容的长度，当达到最大长度时，调用```_focusNode.unfocus();```来关闭软键盘。

* 获取输入内容
&emsp;&emsp;在组件的构造函数里定义ValueChanged<T>回调方法，通过```onChanged(String text){ValueChanged(text)}```来传递输入内容。

```dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

//自定义的验证框
class UtilVerification extends StatefulWidget {
  //完成输入的回调函数
  final ValueChanged<String> onFinish;

  //装饰
  final Decoration decoration;

  //字体
  final TextStyle textStyle;

  //输入数量
  final int textCount;

  //高度
  final double height;

  //单个输入宽度
  final double itemWidth;


  //键盘类型
  final TextInputType keyboardType;
  
  //输入限制
  final List<TextInputFormatter> inputFormatters;

  UtilVerification({
    Key key ,
    this.itemWidth = 44,
    this.textCount = 6,
    this.textStyle,
    this.decoration = const BoxDecoration(
        border: Border(
            bottom: BorderSide(color: Colors.grey)
        )
    ),
    @required this.onFinish,
    this.height = 56,
    this.keyboardType,
    this.inputFormatters
  }) : super(key: key);

  @override
  UtilVerificationState createState() => new UtilVerificationState();
}

class UtilVerificationState extends State<UtilVerification> {

  //焦点
  FocusNode _focusNode;

  //获取输入内容
  TextEditingController _controller;

  //要显示的文字
  List<String> _textList = List<String>();


  @override
  void initState() {
    // TODO: implement initState
    super.initState();
    _focusNode = FocusNode();
    _controller = TextEditingController();
    for(int i = 0;i < widget.textCount;i++){
      _textList.add('');
    }
  }

  @override
  void dispose() {
    _focusNode.dispose();
    _controller.dispose();
    _textList.clear();
    // TODO: implement dispose
    super.dispose();
  }


  List<Widget> _decorations(){
    List<Widget> _items = List<Widget>();
    for(int i = 0;i < widget.textCount;i++){
      _items.add(
        Container(
          width: widget.itemWidth,
          decoration: widget.decoration,
          alignment: Alignment.center,
          child: Text(
            _textList[i],
            style: widget.textStyle,
          ),
        ),
      );
    }
    return _items;
  }



  @override
  Widget build(BuildContext context) {
    return Container(
      height: widget.height,
      child: Stack(
        children: <Widget>[
          TextField(
            focusNode: _focusNode,
            controller: _controller,
            maxLength: widget.textCount,
            inputFormatters: widget.inputFormatters,
            keyboardType: widget.keyboardType,
            textAlign: TextAlign.right,
            showCursor: false,
            style: TextStyle(color: Colors.transparent,fontSize: 1),
            onChanged: (v){
              //输入框的值传递给Text
              for(int i = 0; i < widget.textCount; i++){
                if(i < v.length){
                  _textList[i] = v[i];
                }
                else{
                  _textList[i] = '';
                }
              }
              //达到最大长度关闭软键盘
              if(v.length == widget.textCount){
                _focusNode.unfocus();
                widget.onFinish(_controller.text);
              }
              setState(() {

              });
            },
            decoration: InputDecoration(
                border: InputBorder.none,
                counter: SizedBox.shrink()
            ),
          ),

          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: _decorations(),
          ),

          Listener(
            onPointerDown: (v){
              //点击控件打开软键盘
              FocusScope.of(context).unfocus();
              FocusScope.of(context).requestFocus(_focusNode);
            },
            behavior: HitTestBehavior.opaque,
          )
        ],
      ),
    );
  }
}
```
