# 注意事项
&emsp;&emsp;如果在MainActivity中，`GeneratedPluginRegistrant.registerWith(this);`报错，提示MainActivity类不能被转换成FlutterEngine类，
点进去GeneratedPluginRegistrant类，看看生成的GeneratedPluginRegistrant是否正确。  
&emsp;&emsp;正常的`registerWith()`方法里参数应是`PluginRegistry`类，下面是我第一次生成的错误`GeneratedPluginRegistrant`类：

```java
public final class GeneratedPluginRegistrant {
  public static void registerWith(@NonNull FlutterEngine flutterEngine) {
    flutterEngine.getPlugins().add(new io.flutter.plugins.pathprovider.PathProviderPlugin());
    flutterEngine.getPlugins().add(new io.flutter.plugins.webviewflutter.WebViewFlutterPlugin());
  }
}
```

&emsp;&emsp;正确的`GeneratedPluginRegistrant`：

```java
/**
 * Generated file. Do not edit.
 * This file is generated by the Flutter tool based on the
 * plugins that support the Android platform.
 */
@Keep
public final class GeneratedPluginRegistrant {
  public static void registerWith(PluginRegistry registry) {
    if (alreadyRegisteredWith(registry)) {
      return;
    }
  }

  private static boolean alreadyRegisteredWith(PluginRegistry registry) {
    final String key = GeneratedPluginRegistrant.class.getCanonicalName();
    if (registry.hasPlugin(key)) {
      return true;
    }
    registry.registrarFor(key);
    return false;
  }
}
```

&emsp;&emsp;参考：  
[https://stackoverflow.com/questions/60228403/generatedpluginregistrant-dont-can-not-be-applied-flutter](https://stackoverflow.com/questions/60228403/generatedpluginregistrant-dont-can-not-be-applied-flutter )  
&emsp;&emsp;[https://github.com/theyakka/fluro/blob/master/example/android/app/src/main/java/io/flutter/plugins/GeneratedPluginRegistrant.java#L13](https://github.com/theyakka/fluro/blob/master/example/android/app/src/main/java/io/flutter/plugins/GeneratedPluginRegistrant.java#L13)  
&emsp;&emsp;  

[https://github.com/flutter/flutter/issues/45231](https://github.com/flutter/flutter/issues/45231)
	




# MethodChannel
## 1. Flutter调用Android
* Flutter端  
&emsp;&emsp;Flutter包含三个功能，分别是获取电池电量，不带参数的跳转到Android界面，带参数的跳转到Android界面

```dart

//通过MethodChannel调用连接Android的通道
//单个应用中使用的通道名称必须唯一
static const platform = const MethodChannel('samples.flutter.io/battery');
  
String _batteryLevel = 'Unknown battery level';
String oneAct = '';
String twoAct = '';
	
//获取电池电量
Future<Null> _getBatteryLevel()async{
  //调用可能失败，所以放在try-catch里
  try{
    final int result = await platform.invokeMethod('getBatteryLevel');
    _batteryLevel = 'Battery level at $result %';
  }on PlatformException catch(e){
    _batteryLevel = "Failed to get battery level : '${e.message}";
  }
  setState(() {
		
  });
}
	
//跳转页面不带参数
Future<Null> _jumpToNative() async{
  try{
    oneAct = await platform.invokeMethod('oneAct');
  }on PlatformException catch(e){
    oneAct = "Failed to jump to OneActivity : '${e.message}";
  }
  setState(() {
     
  });
}
	
//跳转页面带参数
Future<Null> _jumpToNativeWithValue() async{
  try{
    Map<String,String> map = {"flutter" : "这是来自flutter的参数"};
   	twoAct = await platform.invokeMethod('twoAct',map);
  }on PlatformException catch(e){
    twoAct = "Failed to jump to TwoActivity : '${e.message}";
  }
  setState(() {
		
  });
}
	
```

***

* Android端
   * 点击File -- Open -- 点开当前项目 -- 选中android -- OK
   * Activity的创建三要素
      1. 新建一个类继承Activity或AppCompatActivity
      2. 在AndroidMainfest中声明(不声明的话无法使用无法跳转)
      3. 创建layout并在Activity中的onCreate里通过setContentView绑定
	
> 添加需要导入的依赖
	
```dart
import android.content.ContextWrapper;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.BatteryManager;
import android.os.Build.VERSION;
import android.os.Build.VERSION_CODES;
import android.os.Bundle;
```

```dart
public class MainActivity extends FlutterActivity  {
    //通道名称,和Flutter端一致
    private static final String CHANNEL = "samples.flutter.io/battery";

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        GeneratedPluginRegistrant.registerWith(this);

        new MethodChannel(getFlutterView(), CHANNEL).setMethodCallHandler(
                new MethodChannel.MethodCallHandler() {
                    @Override
                    public void onMethodCall(MethodCall call, MethodChannel.Result result) {
                        //电池电量
                        if (call.method.equals("getBatteryLevel")) {
                            int batteryLevel = getBatteryLevel();
                            if (batteryLevel != -1) {
                                result.success(batteryLevel);
                            } else {
                                result.error("UNAVAILABLE", "Battery level not available.", null);
                            }
                        }

                        //无参数跳转页面
                        else if(call.method.equals("oneAct")){
                            //跳转到指定Activity
                            Intent intent = new Intent(MainActivity.this,MyFlutterActivity.class);
                            startActivity(intent);
                            //返回给flutter的参数
                            result.success("跳转成功flutter");
                        }

                        //带参数跳转页面
                        else if(call.method.equals("twoAct")){
                            //解析参数
                            String text = call.argument("flutter");

                            //带参数跳转到指定Activity
                            Intent intent = new Intent(MainActivity.this,OtherActivity.class);
                            intent.putExtra(OtherActivity.VALUE,text);
                            startActivity(intent);

                            result.success("跳转成功");
                        }

                        else {
                            result.notImplemented();
                        }
                    }
                });
    }

    //获取电池电量
    public int getBatteryLevel() {
        int batteryLevel = -1;
        if (VERSION.SDK_INT >= VERSION_CODES.LOLLIPOP) {
            BatteryManager batteryManager = (BatteryManager) getSystemService(BATTERY_SERVICE);
            batteryLevel = batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CAPACITY);
        } else {
            Intent intent = new ContextWrapper(getApplicationContext()).
                    registerReceiver(null, new IntentFilter(Intent.ACTION_BATTERY_CHANGED));
            batteryLevel = (intent.getIntExtra(BatteryManager.EXTRA_LEVEL, -1) * 100) /
                    intent.getIntExtra(BatteryManager.EXTRA_SCALE, -1);
        }

        return batteryLevel;
    }
}
```
  
## 2. Android调用Flutter
* Flutter端

```dart
//获取到来自Android端的回调
@override
void initState() {
  // TODO: implement initState
  super.initState();
  platform.setMethodCallHandler(getAndroidCallHandler);
}

String _androidCall = '';
Future<dynamic> getAndroidCallHandler(MethodCall call) async{
  //call.method获取Android调用的方法名
  switch (call.method){
    case "getFlutterContent":
      //call.argument获取Android传递过来的数据
      _androidCall = call.arguments;
      setState(() {

      });
      //成功接收来自Android端的参数后，可以再给Android端返回Flutter端的数据
      return "Flutter端已收到回调";
      break;

    default:
      break;
  }
}
```

* Android端

```java
//通过MethodChannel的invokeMethod方法,调用Flutter里的getFlutterContent
button.setOnClickListener(new View.OnClickListener() {
  @Override
  public void onClick(View view) {
      //参数分别是：方法名、Android传递给Flutter的数据、请求的结果回调
      MainActivity.channel.invokeMethod("getFlutterContent", "来自Android端的参数", new MethodChannel.Result() {
          //调用成功
          @Override
          public void success(Object result) {
              Toast.makeText(MyFlutterActivity.this,"传递成功:" + result.toString(), Toast.LENGTH_SHORT).show();
          }
          //调用失败
          @Override
          public void error(String errorCode, String errorMessage, Object errorDetails) {
              Toast.makeText(MyFlutterActivity.this,"传递错误:" + errorMessage.toString(), Toast.LENGTH_SHORT).show();
          }

          //Flutter未实现对应方法
          @Override
          public void notImplemented() {
              Toast.makeText(MyFlutterActivity.this,"传递notImplemented:" , Toast.LENGTH_SHORT).show();
          }
      });
  }
});
```

* 其他注意点  
&emsp;&emsp;如果希望回调`notImplemented()`,不要在Flutter中调用MethodChannel的`setMethodCallHandler()`方法，或者设置setMethodCallHandler的参数为null。

```dart
//方法一
//    methodChannel.setMethodCallHandler((MethodCall call){
//        if (call?.method == 'getContent') {
//          setState(() {
//            _arguments = call?.arguments ?? '';
//          });
//          return returnToRaw();
//        }
//    });

//方法二
methodChannel.setMethodCallHandler(null);
````

&emsp;&emsp;如果希望回调`error`,修改返回给Android端的数据。

```dart
Future<dynamic> getAndroidCallHandler(MethodCall call) async{
  switch (call.method){
    case "getFlutterContent":
      return returnToRaw();
      break;
  }
}
  
Future<String> returnToRaw() async {
  throw PlatformException(code: 'error code');
}
```

***

# BasicMessageChannel
* Flutter端

```dart
//创建EventChannel
static const eventChannel = const EventChannel('com.example.flutter_battery/stream');
int count = 0;
StreamSubscription _timerSubscription;

void _startTimer(){
  if(_timerSubscription == null){
    //监听EventChannel流，会触发Android onListen回调
    _timerSubscription = eventChannel.receiveBroadcastStream().listen(_updateTimer);
  }
}

void _stopTimer(){
  _timerSubscription?.cancel();
  _timerSubscription = null;
  setState(() {
    count = 0;
  });
}

void _updateTimer(dynamic count){
  print("--------------------$count");
  setState(() {
    this.count = count;
  });
}

@override
void dispose() {
  // TODO: implement dispose
  super.dispose();
  _timerSubscription?.cancel();
  _timerSubscription = null;
}

@override
Widget build(BuildContext context) {
  Row(
    mainAxisAlignment: MainAxisAlignment.spaceAround,
    children: <Widget>[
      FlatButton(
        onPressed: (){
          _startTimer();
        },
        child: Text('开始EventChannel'),
      ),
      FlatButton(
        onPressed: (){
          _stopTimer();
        },
        child: Text('取消EventChannel'),
      ),
      Text('count数值：$count')
    ],
  ),
}
```

* Android端

```java
public class EventChannelPlugin implements EventChannel.StreamHandler {


    private Handler handler;
    private static final String CHANNEL = "com.example.flutter_battery/stream";
    private int count = 0;

    //通过静态函数创建自己
    public static void registerWith(BinaryMessenger registrar) {
        // 新建 EventChannel, CHANNEL常量的作用和 MethodChannel 一样的
        final EventChannel channel = new EventChannel(registrar, CHANNEL);
        // 设置流的处理器(StreamHandler)
        channel.setStreamHandler(new EventChannelPlugin());
    }




    @Override
    public void onListen(Object arguments, EventChannel.EventSink events) {
        //每隔一秒数字 + 1
        handler = new Handler(message -> {
            Log.e("BatteryPlugin", "onListen获取到的参数 : " + arguments);
            //然后把数字发送给Flutter
            events.success( ++ count);
            handler.sendEmptyMessageDelayed(0,1000);
            return  false;
        });
        handler.sendEmptyMessage(0);
    }

    @Override
    public void onCancel(Object arguments) {
        handler.removeMessages(0);
        handler = null;
        count = 0;
    }
}


public class MainActivity extends FlutterActivity  {
    @Override
    public void onCreate(Bundle savedInstanceState) {
      ......
      EventChannelPlugin.registerWith(getFlutterView());
    }
}

```


	
	
	
	
